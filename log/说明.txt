同步日志，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。

生产者-消费者模型，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，本例中是一个队列，用循环数组实现其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。

阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。

异步日志，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。
这个缓冲区就像底层调用read或者write，write时并不是直接将内容写入到磁盘文件，而是写入到内存缓冲，当然flush可以刷缓冲，实现强制写入。
这里用一个循环数组模拟了内存缓冲

单例模式，最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。


实际中每个进程(生产者)通过提供的四种调用写日志，通过调用日志单例log::get_instance()的write_log函数，日志内容也就是一个string串写入到也就是push到阻塞队列中去，
如果是同步模式，日志内容直接写入到文件，
异步模式，日志内容写入到阻塞队列，然后在条件变量队列上休眠的所有线程都被唤醒，消费者子线程会被唤醒，其负责从阻塞队列pop出一个，然后通过fputs函数将pop出的字符串写入到日志文件(但是有可能只是写入到内核缓冲区)，
然后又继续下一次pop不停，直到在某一次pop过程中，因为阻塞队列为空陷入睡眠，又会等待下一次进程异步写日志，将其唤醒

但是有一个问题，在大多数情况下，fputs会立即将字符串写入到文件中。然而，有些情况下，为了提高性能和效率，操作系统和文件系统可能会使用内存缓冲区来暂存数据，然后再以较大的块将数据写入到磁盘。
这种缓冲通常是由操作系统和文件系统自动处理的，而不是由fputs函数直接控制的。
因此，如果我们想要动态监测程序运行过程中产生的log，可以在写日志后时不时刷缓冲，通过调用日志类提供的flush函数，将缓冲区数据写入磁盘文件